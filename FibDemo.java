/*=============================================================================
|    Source code: FibDemo.java
|    Assignment:  Assignment 6 Recursive Fibonacci
|
|        Course:  COP 3337 (Intermediate Programming)
|        Section:  U06
|
|
|       Language: Java
|       Compile/Run:
|
|        javac FibDemo.java ArithmeticOverflowException.java
|              UserInvalidValueException.java
|              FastFibSequence.java FastLoopFibSequence.java
|              FibSequence.java Sequence.java
|              LoopFibSequence.java
|
|       java FibDemo inputFile outputFile
|
|  +-----------------------------------------------------------------------------
|
|  Description:  This program determines the amount of time required to display a
|                fibonacci sequence given different algorithms and displays the sequence
|                generated by each of the algorithms.
|
|
|       Input:    (Command line input)
|                 [inputFile] A file containing the two values required to run the program
|                 [outputFile] A file where the fib sequence and time will be displayed
|
|                 (Text File Input)
|                 Two integers separated by a carriage return
|                 The first integer represent the starting position for the fibonacci sequence. range [1-12] inclusive
|                 The second integer represents the number of Fibonacci numbers to be displayed range [1 - 36] inclusive
|
|
|       Output:   The fib sequence along with the algorithm class used to create it and time is displayed in an output file.
|
|       Process:  The program's steps are as follows:
|
|                      1.  The user runs the program on the command line specifying an input file and an output file
|
|                          i.e java FibDemo inputFile outputFile
|
|                      2.  The program reads the input inside the input file and executes the methods to create the fib
|                          sequence for each of the algorithms.
|
|                      3.  The fib sequence along with the algorithm class used to create it and time is displayed
|                          in the output file.
|
|                 No particular algorithms are used in the FibDemo class
|
|
|   Required Features Not Included: All required features are included.
|
|   Known Bugs:  None; the program operates correctly.
|
|  *===========================================================================*/


import java.io.FileNotFoundException; // Handel file not found
import java.io.PrintWriter; // Write data to txt file
import java.io.File; // Interact with txt file
import java.util.Scanner; // Reading txt file
import java.io.FileOutputStream; // choose between appending or overwriting files
import java.util.List; // Save getFibNumber seq and time information for classes
import java.util.ArrayList; // Save getFibNumber seq and time information for classes

public class FibDemo
{

    private static final int ROW_INDEX = 0;
    private static final int COLUMN_INDEX = 1;

    private static final int AMOUNT_OF_INPUT_EXPECTED = 2;
    private static final int FIRST_INPUT_INDEX = 0;
    private static final int SECOND_INPUT_INDEX = 1;

    private static final int LOOP_FIB_SEQ_CLASS_INDEX = 0;
    private static final int FAST_LOOP_SEQ_CLASS_INDEX = 1;
    private static final int FIB_SEQ_CLASS_INDEX = 2;
    private static final int FAST_FIB_SEQ_CLASS_INDEX = 3;

    private static final int NUMBER_OF_CLASSES = 4;

    private static final int FIB_SEQ_INDEX = 0;
    private static final int TIME_INDEX = 1;

    private static final int IN_FILE_INDEX = 0;
    private static final int OUT_FILE_INDEX = 1;

    private static final String FIRST_INPUT_ERROR = "Input One (Starting Position For The Fibonacci Sequence) ";
    private static final String SECOND_INPUT_ERROR = "Input Two (Number of Fibonacci Numbers To Be Displayed) ";
    private static final String  VALID_INPUT_MSG =
            " A valid input consist of two integers separated by a carriage return. \n" +
                    " The first integers dictates where the Fibonacci sequence will start, beginning " +
                    " with the next Fibonacci number range [0 - 12] inclusive.\n" +
                    " The second integer represent the number of Fibonacci numbers to be displayed range [1 - 36] inclusive\n";


    public static void main(String[] args)
    {
        checkCommandLineInputAmount(args.length);

        String[] formattedInput = formatCommandLineInput(args);

        final String IN_FILE = formattedInput[IN_FILE_INDEX];
        final String OUT_FILE = formattedInput[OUT_FILE_INDEX];

        Sequence fibonacciClasses[] = new Sequence[NUMBER_OF_CLASSES];

        final boolean APPEND_FILE = false;

        final int[] VALID_USER_INPUT = readUserInput(IN_FILE);

        final int START_NUMBER = VALID_USER_INPUT[FIRST_INPUT_INDEX];
        final int FIB_TO_DISPLAY = VALID_USER_INPUT[SECOND_INPUT_INDEX];

        System.out.println(" [" + IN_FILE + " contains: " + START_NUMBER + " & " + FIB_TO_DISPLAY + "]");

        LoopFibSequence loopFib = new LoopFibSequence(START_NUMBER);
        FastLoopFibSequence fastLoop = new FastLoopFibSequence(START_NUMBER);
        FibSequence fibSeq = new FibSequence(START_NUMBER);
        FastFibSequence fastFibSeq = new FastFibSequence(START_NUMBER);

        int[] overflowIndicators = overflowClassIndicators(loopFib, fastLoop, fibSeq, fastFibSeq);

        fibonacciClasses[LOOP_FIB_SEQ_CLASS_INDEX] = loopFib;
        fibonacciClasses[FAST_LOOP_SEQ_CLASS_INDEX] = fastLoop;
        fibonacciClasses[FIB_SEQ_CLASS_INDEX] = fibSeq;
        fibonacciClasses[FAST_FIB_SEQ_CLASS_INDEX] = fastFibSeq;

        runProgram(fibonacciClasses, APPEND_FILE, FIB_TO_DISPLAY, OUT_FILE, overflowIndicators);

    }

    /**
     * Checks to see if the user entered the correct number of inputs.
     * If the validation fails an exception will be thrown.
     *
     * @param commandInputAmount command line inputs
     */

    public static void checkCommandLineInputAmount(int commandInputAmount)
    {
        final int EXPECTED_COMMAND_LINE_INPUT_AMOUNT = 2;

        if (commandInputAmount != EXPECTED_COMMAND_LINE_INPUT_AMOUNT)
        {
            String inputErrorMsg = "\n Command Line Input Must Specify An Input File And An Output file.";
            String throwMsg = "Invalid Number Of Command-Line Inputs.";

            try
            {
                throw new UserInvalidValueException(throwMsg);

            } catch (UserInvalidValueException exception)
            {
                System.err.println("\n " + exception.toString());
                System.err.println(inputErrorMsg + "\n");
                System.exit(1);
            }

        }
    }


    public static int[] overflowClassIndicators(LoopFibSequence loopFib ,FastLoopFibSequence fastLoop,  FibSequence fibSeq, FastFibSequence fastFibSeq )
    {
        int[] overflowIndicators = new int[NUMBER_OF_CLASSES];

        overflowIndicators[LOOP_FIB_SEQ_CLASS_INDEX] = loopFib.OVERFLOW_VALUE;
        overflowIndicators[FAST_LOOP_SEQ_CLASS_INDEX] = fastLoop.OVERFLOW_VALUE;
        overflowIndicators[FIB_SEQ_CLASS_INDEX] = fibSeq.OVERFLOW_VALUE;
        overflowIndicators[FAST_LOOP_SEQ_CLASS_INDEX] = fastFibSeq.OVERFLOW_VALUE;

        return overflowIndicators;
    }


    /**
     * Adds a .txt extension if the input / output files do not contain a .txt extension
     *
     * @param commandLineInput An array containing the input and output file
     * @return An input and output file with a .txt extension
     */

    public static String[] formatCommandLineInput(String[] commandLineInput)
    {
        final String FILE_EXTENSION = ".txt";

        final int FILE_EXTENSION_LENGTH = FILE_EXTENSION.length();

        int checkTxtStart = 0;
        int checkTxtEnd = 0;

        String checkForTxt = "";

        String[] editCommandLineInput = commandLineInput;

        for (int file = 0; file < editCommandLineInput.length; file++)
        {
            if (editCommandLineInput[file].length() < FILE_EXTENSION_LENGTH)
            {
                editCommandLineInput[file] += FILE_EXTENSION;
            }else
            {
                checkTxtStart = editCommandLineInput[file].length() - FILE_EXTENSION_LENGTH;
                checkTxtEnd = editCommandLineInput[file].length();
                checkForTxt = editCommandLineInput[file].substring(checkTxtStart, checkTxtEnd);

                if (!checkForTxt.equals(FILE_EXTENSION))
                {
                    editCommandLineInput[file] += FILE_EXTENSION;
                }
            }
        }

        return editCommandLineInput;
    }


    /**
     * Calls the necessary methods needed to execute the program
     *
     * @param fibClasses An array containing all the fibonacci classes
     * @param appendToFile A boolean value denoting if the user wants to append or overwrite the output file
     * @param seqToDisplay The amount of sequences the user wants to display [1 - 36]
     * @param outFile The name of the output file
     */

    public static void runProgram(Sequence[] fibClasses, boolean appendToFile, int seqToDisplay, String outFile, int[] overflowIndicators)
    {

        int WORST_CASE_OUTPUT_TIME = 60; // seconds

        boolean[] appendOutputOptionPerClass = new boolean[NUMBER_OF_CLASSES];

        List<String[][]> infoForFibClass = new ArrayList<>();

        final String[] seqName = {"Iterative - Expected", "Fast Iterative", "Normal Recursive", "Fast Recursive"};



        System.out.println(" The output process could take about " + WORST_CASE_OUTPUT_TIME + " seconds\n ");


        // First getFibNumber table displayed in the file determines if the file should be overwritten or appended
        appendOutputOptionPerClass[LOOP_FIB_SEQ_CLASS_INDEX] = appendToFile;

        // Append the remaining getFibNumber tables
        for (int appendRemainingClasses = 1; appendRemainingClasses < fibClasses.length; appendRemainingClasses++)
        {
            appendOutputOptionPerClass[appendRemainingClasses] = true;
        }

        // Get the getFibNumber sequence and execution time for each getFibNumber class
        for (int fibClassIndex = LOOP_FIB_SEQ_CLASS_INDEX; fibClassIndex < NUMBER_OF_CLASSES; fibClassIndex++)
        {
            infoForFibClass.add(createFibonacciSequence(seqToDisplay,  fibClasses[fibClassIndex]));
        }

        // Display each getFibNumber table
        for (int fibClassIndex = LOOP_FIB_SEQ_CLASS_INDEX; fibClassIndex < NUMBER_OF_CLASSES; fibClassIndex++)
        {
            String[][] fibClass = infoForFibClass.get(fibClassIndex);

            // 0 col where TimeIndex is located
            outputFibTable(fibClass[FIB_SEQ_INDEX], fibClass[TIME_INDEX][0], seqName[fibClassIndex],
                    appendOutputOptionPerClass[fibClassIndex], outFile, fibClassIndex, overflowIndicators[fibClassIndex]);
        }
    }


    /***
     *
     * Creates the getFibNumber sequence for the given class and get the time it took to create the sequences
     *
     * @param sizeOfSequence The amount of getFibNumber numbers to be displayed
     * @param fibSequenceToCreate The class that will create the getFibNumber numbers
     * @return An array containing the getFibNumber sequence and the time it took to create the sequence
     */

    public static String[][] createFibonacciSequence(int sizeOfSequence, Sequence fibSequenceToCreate)
    {
        final int AMOUNT_OF_INFO_TO_STORE = 2;

        long startTime = 0;
        long endTime = 0;
        long elapsedTimeNano = 0;


        String[] fibSequence = new String[sizeOfSequence];
        String[][] fibSequenceInfo = new String[AMOUNT_OF_INFO_TO_STORE][1]; // 1 column where info will be stored

        startTime = System.nanoTime();

        for (int fibNumber = 0; fibNumber < sizeOfSequence; fibNumber++)
        {
            fibSequence[fibNumber] = Integer.toString(fibSequenceToCreate.next());
        }

        endTime = System.nanoTime();

        elapsedTimeNano = endTime - startTime;

        fibSequenceInfo[FIB_SEQ_INDEX] = fibSequence;
        fibSequenceInfo[TIME_INDEX][0] = Long.toString(elapsedTimeNano); // 0 col where time info will be stored

        return fibSequenceInfo;
    }


    /**
     *
     * Neatly outputs the contents of the createFibonacciSequence method for one class into an output file.
     *
     *
     * Formula:
     *        Nanoseconds to seconds
     *
     *        1 Nanosecond = 1_000_000_000.0 seconds
     *
     * @param fibSeq The getFibNumber sequence that will be outputted
     * @param nanoTimeLong The time it took to create the getFibNumber sequence
     * @param sequenceType Information about the class which the sequence if from to be displayed
     * @param append whether or not the contents will be appended to the file
     * @param fileName The file to append the content to
     * @param fibClass An int denoting the class being outputted. Used in case of overflow
     */

    public static void outputFibTable(String[] fibSeq, String nanoTimeLong, String sequenceType, boolean append, String fileName, int fibClass, int overflowIndicator)
    {

        int[] tableDimensions = squareTableDimensions(fibSeq.length);

        int start_next_row_counter = 0;
        int spacesToAlignNumbers = 0;

        long elapsedNanoTime = Long.parseLong(nanoTimeLong);

        double nanoToSeconds = elapsedNanoTime / 1_000_000_000.0;



        String[] cleanedOutput = checkOutputForOverflow(fibSeq, fibClass, overflowIndicator);


        spacesToAlignNumbers = (cleanedOutput[cleanedOutput.length - 1]).length(); // - 1 last index


        try
        {

            PrintWriter output = new PrintWriter(new FileOutputStream(new File(fileName), append));

            output.println(sequenceType);

            for (String aFibSequence : cleanedOutput)
            {
                output.printf("%2s%" + spacesToAlignNumbers + "s%3s","", aFibSequence, "");
                start_next_row_counter++;

                if (start_next_row_counter == tableDimensions[1]) // 1 column index where info stored
                {
                    start_next_row_counter = 0;
                    output.println();
                }
            }

            output.printf("\nTime to compute: %,d nanoseconds, %.4f seconds \n", elapsedNanoTime, nanoToSeconds);
            output.println();

            output.close();

        }catch (FileNotFoundException exception)
        {
            System.err.println("\n\n" + exception.toString());
            exception.printStackTrace();
            System.exit(1);
        }
    }


    /**
     * Checks to see if the outputted getFibNumber seq contains overflow values and changes the overflow values into *
     *
     * @param fibSeq The getFibNumber seq to be analyzed
     * @param currentClassIndex An int denoting the class being outputted
     * @return If an overflow was found, overflowed values replaced with * otherwise the same values are returned
     */

    public static String[] checkOutputForOverflow(String[] fibSeq, int currentClassIndex, int overflowIndicator)
    {

        int currentIndex = 0;
        String errorMsg = "";


        try
        {
            for (String aFibSeq : fibSeq)
            {

                if (Long.parseLong(aFibSeq) == overflowIndicator)
                {
                    errorMsg = fibOverflowMsg(currentClassIndex);
                    throw new ArithmeticOverflowException(errorMsg);
                }
                currentIndex++;
            }

            return fibSeq;

        }catch (ArithmeticOverflowException exception)
        {

            System.err.println(" " + exception.toString() + "\n");

            return formatOverflowNumbers(fibSeq, currentIndex);
        }
    }


    /**
     * Turns a class index into a msg used to tell the user which class has an overflow
     *
     * @param currentClassIndex The index of the class that has the overflow
     * @return A message denoting that the class has an overflow
     */


    public static String fibOverflowMsg(int currentClassIndex)
    {

        final String REPLACE_MSG = " Overflow values have been replaced with a *";

        String errorMsg = "An overflow was detected for ";

        if (currentClassIndex == FIB_SEQ_CLASS_INDEX)
        {
            errorMsg += "Fib Sequence\n";

        }else if (currentClassIndex == FAST_FIB_SEQ_CLASS_INDEX)
        {
            errorMsg += "Fast Fib Sequence\n";

        }else if (currentClassIndex == LOOP_FIB_SEQ_CLASS_INDEX)
        {
            errorMsg += "Loop Fib Sequence\n";

        }else if (currentClassIndex == FAST_LOOP_SEQ_CLASS_INDEX)
        {
            errorMsg += "Fast loop Fib Sequence\n";
        }

        errorMsg += REPLACE_MSG;

        return errorMsg;
    }


    /***
     *
     * Changes the overflow values into a * with the length of the getFibNumber number before the overflow occurred
     *
     * @param fibSeq The array that contains an overflow value
     * @param overflowIndex The index that the overflow was detected
     * @return An array of all the getFibNumber seq with formatted overflow values
     */
    public static String[] formatOverflowNumbers(String[] fibSeq, int overflowIndex)
    {
        final String OVERFLOW_REPLACEMENT = "*";

        String cleanOverflowResult = "";
        String[] cleanFibSeq = fibSeq;

        for (int valuesToChange = overflowIndex; valuesToChange < cleanFibSeq.length; valuesToChange++)
        {
            cleanOverflowResult = "";


            // Replace all values starting from overflow onwards with OVERFLOW_REPLACEMENT
            for (int asterisk = 0; asterisk < cleanFibSeq[valuesToChange - 1].length(); asterisk++) // - 1 last index
            {
                cleanOverflowResult += OVERFLOW_REPLACEMENT;
            }
            cleanFibSeq[valuesToChange] = cleanOverflowResult;
        }

        return cleanFibSeq;
    }


    /**
     * Determines the row and col needed to make a square table with a set number of elements
     *
     * @param numOfSequence number of elements to be squared
     * @return array with values needed to display a square table
     */
    public static int[] squareTableDimensions(int numOfSequence)
    {

        int rowSize = 0;
        int colSize = 0;

        int[] dimensions = {rowSize, colSize};

        colSize = (int) Math.ceil(Math.sqrt(numOfSequence));
        rowSize = colSize ;

        dimensions[ROW_INDEX] = rowSize;
        dimensions[COLUMN_INDEX] = colSize;

        return dimensions;
    }

    /***
     * Reads and checks that the contents of the input file are adequate
     *
     * @param InputFileName The file to be read from
     * @return the contents of the input file containing the start getFibNumber number and the number of getFibNumber seq to be created
     */

    public static int[] readUserInput(String InputFileName)
    {
        String possibleValidInput = "";

        int[] userInput = new int[AMOUNT_OF_INPUT_EXPECTED];
        int amountOfInputs = 0;

        String textFileInput = "";
        String firstInput = "";
        String secondInput = "";



        try
        {
            File inputFile = new File(InputFileName);

            Scanner readInput = new Scanner(inputFile);

            while (readInput.hasNextLine())
            {
                textFileInput = readInput.nextLine();
                amountOfInputs += 1;

                if (textFileInput.contains(" "))
                {
                    amountOfInputs += AMOUNT_OF_INPUT_EXPECTED ; // To Invalidate inputs that are in the same line
                }else
                {
                    possibleValidInput += textFileInput + "\n";
                }
            }

            readInput.close();

            checkValidNumberOfInputs(amountOfInputs, inputFile);

            firstInput = possibleValidInput.split("\n")[FIRST_INPUT_INDEX];
            secondInput = possibleValidInput.split("\n")[SECOND_INPUT_INDEX];

            checkInputForOverflow(firstInput, secondInput);

            checkInputType(firstInput, secondInput);

            userInput[FIRST_INPUT_INDEX] = Integer.parseInt(possibleValidInput.split("\n")[FIRST_INPUT_INDEX]);
            userInput[SECOND_INPUT_INDEX] = Integer.parseInt(possibleValidInput.split("\n")[SECOND_INPUT_INDEX]);

            checkValidInputRange(userInput);


        }catch (FileNotFoundException exception)
        {
            System.err.println("\n\n" + exception.toString());
            System.err.println("No File Named: \"" + InputFileName + "\" Was Found.");
            System.exit(1);
        }

        return userInput;
    }


    /**
     * Checks to see if a valid number of inputs are in the file.
     * If the validation fails an exception will be thrown.
     *
     * @param amountOfInputs The amount of inputs detected in the file
     * @param inputFile The file to be checked
     */

    public static void checkValidNumberOfInputs(int amountOfInputs, File inputFile)
    {

        try
        {
            final int EMPTY_FILE_LENGTH = 0;

            if (inputFile.length() == EMPTY_FILE_LENGTH)
            {
                throw new UserInvalidValueException("Empty File");


            }else if (amountOfInputs != AMOUNT_OF_INPUT_EXPECTED)
            {
                throw new UserInvalidValueException("Invalid Number Of Inputs In Input File");
            }

        }catch(UserInvalidValueException exception)
        {
            System.err.println("\n " + exception.toString() + "\n");
            System.err.println(VALID_INPUT_MSG);
            System.exit(1);
        }
    }

    /**
     * Checks to see if the file contains integers bigger than Integer.MAX_VALUE
     * If the validation fails an exception will be thrown.
     *
     * @param firstValue the first input in the input file
     * @param secondValue the second input in the input file
     */


    public static void checkInputForOverflow(String firstValue, String secondValue)
    {

       final String TO_LARGE_INPUT = "Is Bigger Than The Highest Value A Type Int Can Have.";
       final String TO_SMALL_INPUT = "Is Smaller Than The Smallest Value A Type Int Can Have.";

        final String REGEX_CHECK_FOR_POSITIVE_INT = "[0-9]+";
        final String REGEX_CHECK_FOR_NEGATIVE_INT = "-[0-9]+";

        boolean firstValueIsPositiveInt  = firstValue.matches(REGEX_CHECK_FOR_POSITIVE_INT);
        boolean secondValueIsPositiveInt = secondValue.matches(REGEX_CHECK_FOR_POSITIVE_INT);

        boolean firstValueIsNegativeInt = firstValue.matches(REGEX_CHECK_FOR_NEGATIVE_INT);
        boolean secondValueIsNegativeInt = secondValue.matches(REGEX_CHECK_FOR_NEGATIVE_INT);

        try
        {
            if (firstValueIsPositiveInt)
            {

                if (Long.parseLong(firstValue) > Integer.MAX_VALUE)
                {
                    throw new ArithmeticOverflowException(FIRST_INPUT_ERROR + TO_LARGE_INPUT);
                }

            }

            if (secondValueIsPositiveInt)
            {
                if (Long.parseLong(secondValue) > Integer.MAX_VALUE)
                {
                    throw new ArithmeticOverflowException(SECOND_INPUT_ERROR + TO_LARGE_INPUT);
                }
            }


            if (firstValueIsNegativeInt)
            {
                if (Long.parseLong(firstValue)  < Integer.MIN_VALUE)
                {
                    throw new ArithmeticOverflowException(FIRST_INPUT_ERROR + TO_SMALL_INPUT);
                }
            }

            if (secondValueIsNegativeInt)
            {
                {
                    if (Long.parseLong(secondValue) < Integer.MIN_VALUE)
                    {
                        throw new ArithmeticOverflowException(SECOND_INPUT_ERROR + TO_SMALL_INPUT);
                    }

                }
            }


        }catch (NumberFormatException exception)
        {
            longOverflow(firstValueIsNegativeInt, secondValueIsNegativeInt);

        }catch (ArithmeticOverflowException exception)
        {
            System.err.println("\n\n " + exception.toString() + "\n");
            System.err.println(VALID_INPUT_MSG);
            System.exit(1);
        }
    }

    /**
     * Displays a message if the integer in the file is bigger / smaller than a long
     *
     * @param firstNegative  if the value of the first integer is negative
     * @param secondNegative if the value of the second integer is negative
     */
    public static void longOverflow(boolean firstNegative, boolean secondNegative)
    {
        final String TO_LARGE_INPUT = "Integer Is Bigger Than The Highest Value A Type Int Can Have.";
        final String TO_SMALL_INPUT = "Integer Is Smaller Than The Smallest Value A Type Int Can Have." ;

        try
        {
            if (firstNegative || secondNegative)
            {
                throw new ArithmeticOverflowException(TO_SMALL_INPUT);

            }else
            {
                throw new ArithmeticOverflowException(TO_LARGE_INPUT);
            }
        }catch (ArithmeticOverflowException exception)
        {
            System.err.println("\n\n " + exception.toString() + "\n");
            System.err.println(VALID_INPUT_MSG);
            System.exit(1);
        }

    }




    /**
     * Checks to see if the data inside the file is an int
     * If the validation fails an exception will be thrown.
     *
     * @param firstValue the first input in the input file
     * @param secondValue the second input in the input file
     */
    public static void checkInputType(String firstValue, String secondValue)
    {

        final String REGEX_CHECK_FOR_POSITIVE_INT = "[0-9]+";
        final String REGEX_CHECK_FOR_NEGATIVE_INT = "-[0-9]+";
        final String NON_INT_MSG = "A Non-Integer Value Was Detected In The File For ";


        boolean firstValueIsPositiveInt  = firstValue.matches(REGEX_CHECK_FOR_POSITIVE_INT);
        boolean secondValueIsPositiveInt = secondValue.matches(REGEX_CHECK_FOR_POSITIVE_INT);

        boolean firstValueIsNegativeInt = firstValue.matches(REGEX_CHECK_FOR_NEGATIVE_INT);
        boolean secondValueIsNegativeInt = secondValue.matches(REGEX_CHECK_FOR_NEGATIVE_INT);

        try
        {
            if (!firstValueIsPositiveInt && !firstValueIsNegativeInt)
            {
                throw new UserInvalidValueException(NON_INT_MSG + FIRST_INPUT_ERROR);

            } else if (!secondValueIsPositiveInt && !secondValueIsNegativeInt)
            {
                throw new UserInvalidValueException(NON_INT_MSG + SECOND_INPUT_ERROR);
            }

        }catch (UserInvalidValueException exception)
        {
            System.err.println("\n\n " + exception.toString() + "\n");
            System.err.println(VALID_INPUT_MSG);
            System.exit(1);
        }

    }


    /**
     * Checks to see if the inputs in the input file are in the valid range
     * If the validation fails an exception will be thrown.
     *
     * @param inputs a list containing the inputs of the input file
     */
    public static void checkValidInputRange(int[] inputs)
    {
        final int FIRST_INPUT_MIN_RANGE = 0;
        final int FIRST_INPUT_MAX_RANGE = 12;

        final int SECOND_INPUT_MIN_RANGE = 1;
        final int SECOND_INPUT_MAX_RANGE = 36;

        final String OUT_OF_RANGE_MSG = "Input Out Of Range";

        try
        {

            if (inputs[FIRST_INPUT_INDEX] < FIRST_INPUT_MIN_RANGE || inputs[FIRST_INPUT_INDEX] > FIRST_INPUT_MAX_RANGE)
            {
                throw new UserInvalidValueException(OUT_OF_RANGE_MSG + FIRST_INPUT_ERROR);

            }else if (inputs[SECOND_INPUT_INDEX] < SECOND_INPUT_MIN_RANGE || inputs[SECOND_INPUT_INDEX] > SECOND_INPUT_MAX_RANGE)
            {
                throw new UserInvalidValueException(OUT_OF_RANGE_MSG + SECOND_INPUT_ERROR);
            }

        }catch (UserInvalidValueException exception)
        {
            System.err.println("\n\n" + exception.toString() + "\n\n");
            System.err.println(VALID_INPUT_MSG);
            System.exit(1);
        }

    }
}